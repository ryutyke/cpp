#include <iostream>
using namespace std;

// 메모리 구조 복습
// - 실행할 코드가 저장되는 영역 -> 코드 영역
// - 전역(global)/정적(static) 변수 -> 데이터 영역
// - 지역 변수/매개 변수 -> 스택 영역
// - 동적 할당 - 힙 영역

// 굳이 새로운 영역?
// 실제 상황을 예로)
// - MMORPG 동접 1명 ~ 5만명, 몬스터 1마리 ~ 500만마리
// - 몬스터 생성 이벤트 -> 5분동안 몬스터가 10배 많이 나옴 (유동적 변화 가능해야함)

// - 스택 영역
// 함수가 끝나면 같이 정리되는 불안정한 메모리
// 잠시 함수에 매개변수 넘긴다거나 하는 용도로는 ok
// - 메모리 영역
// 프로그램이 실행되는 도중에 '무조건' 사용되는

// 희망사항)
// - 필요할때만 사용하고, 필요없으면 반납할 수 있는!
// -- 그러면서도 스택과 다르게 우리가 생성/소멸 시점을 관리할 수 있는 메모리
// -> heap
// 동적할당과 연관된 함수/연산자 : malloc, free, new, delete, new[], delete[]

// malloc
// - 할당할 메모리 크기를 건내준다
// - 메모리 할당 후 시작 주소를 가리키는 포인터를 반환해준다 (메모리 부족할 시 NULL)
// malloc(12) 해도 12바이트 외에 free시 사용할 얼마나 할당해줬는지 등 정보 저장을 위해 메모리 더 씀

// free
// - malloc (혹은 기타 calloc, realloc 등의 사촌) 을 통해 할당된 영역을 해제

class Monster
{
public:
	int _hp;
	int _x;
	int _y;
};

//Monster monster[500 * 10000]; // 되긴 함 하지만 메모리 낭비가 심함

int main()
{
	//Monster monster[500 * 10000]; // 스택 오버플로우
	
	// 유저 영역 [메모장] [LOL] [곰플레이어]
	// --------------------------------------
	// 커널 영역 (Windows 등의 핵심 코드)

	// 유저 영역) 운영체제에서 제공하는 API(함수) 호출
	// 커널 영역) 메모리 할당해서 건내줌
	// 커널 영역에다가 자주 요청하는 것 안좋음
	// 그래서 [      메        모         리         ] 한번에 크게 받아서 나눠서 씀

	// C++에서는 기본적으로 CRT(C런타임 라이브러리리)의 [힙 관리자]를 통해 힙 영역 사용
	// 단, 정말 원한다면 우리가 직접 API를 통해 힙을 생성하고 관리할 수도 있음 (MMORPG 서버 메모리 풀링)

	// void* ? -> 타고 가면 void 뭐가 있는지 모르겠으니깐 알아서 변환해서 사용해라
	void* pointer = malloc(sizeof(Monster)); // [      메        모         리         ] 에서 Monster 크기 만큼 떼서 시작 주소 줌
	
	Monster* m1 = (Monster*)pointer;
	m1->_hp = 100;
	m1->_x = 1;
	m1->_y = 2;

	// Heap Overflow
	// -유효한 힙 범위를 초과해서 사용하는 문제

	free(pointer);
	// free를 해도 메모리 속 데이터가 없어진 것은 아님
	// Use-After-Free 를 막기 위해 nullptr 해주는 것 좋음
	pointer = nullptr;
	m1 = nullptr;

	return 0;
}